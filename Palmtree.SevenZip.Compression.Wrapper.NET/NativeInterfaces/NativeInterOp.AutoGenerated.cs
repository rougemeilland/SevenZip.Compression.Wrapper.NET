// This file is automatically generated. Do not rewrite manually.

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace SevenZip.Compression.NativeInterfaces
{
    partial class NativeInterOp
    {
        #region IUnknown

        #region IUnknown_QueryInterface

        /// <summary>
        /// Gets the interface object for accessing the specified IUnknown interface object on the specified interface.
        /// </summary>
        /// <param name="ifp">Set a pointer to the IUnknown interface object.</param>
        /// <param name="iid">Set the reference of the <see cref="NativeGUID"/> structure of the interface you want to access.</param>
        /// <param name="intefaceObject">If the function call is successful, a pointer to the object to access this object will be output on the interface specified by <paramref name="iid"/>.</param>
        /// <returns><para>If <see cref="HRESULT.S_OK"/> is returned, it means that the call to this function was successful.</para><para>If <see cref="HRESULT.E_NOINTERFACE"/> is returned, it means that the call to this function failed because the object specified by <paramref name="ifp"/> does not support the interface specified by <paramref name="iid"/>.</para><para>If a value other than the above is returned, it means that the function call failed due to some error. At this time, the return value means the reason for the error.</para></returns>
        /// <remarks>If the call to this function is successful, the reference counter for the retrieved interface object has already been incremented. When you no longer need that interface object, you need to decrement the reference counter by calling the <see cref="IUnknown__Release(IntPtr)"/> function.</remarks>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT IUnknown__QueryInterface(IntPtr ifp, ref NativeGUID iid, out IntPtr intefaceObject)
        {
            if (OperatingSystem.IsWindows())
                return IUnknown__QueryInterface_win(ifp, ref iid, out intefaceObject);
            else if (OperatingSystem.IsLinux())
                return IUnknown__QueryInterface_linux(ifp, ref iid, out intefaceObject);
            else if (OperatingSystem.IsMacOS())
                return IUnknown__QueryInterface_osx(ifp, ref iid, out intefaceObject);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__QueryInterface")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT IUnknown__QueryInterface_win(IntPtr ifp, ref NativeGUID iid, out IntPtr intefaceObject);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__QueryInterface")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IUnknown__QueryInterface_linux(IntPtr ifp, ref NativeGUID iid, out IntPtr intefaceObject);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__QueryInterface")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IUnknown__QueryInterface_osx(IntPtr ifp, ref NativeGUID iid, out IntPtr intefaceObject);

        #endregion //IUnknown_QueryInterface

        #region IUnknown_AddRef

        /// <summary>
        /// Increments the object's reference count.
        /// </summary>
        /// <param name="ifp">Set a pointer to the IUnknown interface object.</param>
        /// <returns>Returns an incremented reference count.</returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static UInt32 IUnknown__AddRef(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return IUnknown__AddRef_win(ifp);
            else if (OperatingSystem.IsLinux())
                return IUnknown__AddRef_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return IUnknown__AddRef_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__AddRef")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial UInt32 IUnknown__AddRef_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__AddRef")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IUnknown__AddRef_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__AddRef")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IUnknown__AddRef_osx(IntPtr ifp);

        #endregion //IUnknown_AddRef

        #region IUnknown_Release

        /// <summary>
        /// Decrement the reference count of an object.
        /// </summary>
        /// <param name="ifp">Set a pointer to the IUnknown interface object.</param>
        /// <returns>Returns an incremented reference count.</returns>
        /// <remarks>If the decrement results in a reference count of zero, the object is destroyed and the value of <paramref name="ifp"/> is invalid. And then using the same <paramref name="ifp"/> value will cause unexpected results.</remarks>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static UInt32 IUnknown__Release(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return IUnknown__Release_win(ifp);
            else if (OperatingSystem.IsLinux())
                return IUnknown__Release_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return IUnknown__Release_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__Release")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial UInt32 IUnknown__Release_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__Release")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IUnknown__Release_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IUnknown__Release")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IUnknown__Release_osx(IntPtr ifp);

        #endregion //IUnknown_Release

        #endregion // IUnknown

        #region ISequentialInStream

        #region ISequentialInStream_Read

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ISequentialInStream__Read(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize)
        {
            if (OperatingSystem.IsWindows())
                return ISequentialInStream__Read_win(ifp, data, size, out processedSize);
            else if (OperatingSystem.IsLinux())
                return ISequentialInStream__Read_linux(ifp, data, size, out processedSize);
            else if (OperatingSystem.IsMacOS())
                return ISequentialInStream__Read_osx(ifp, data, size, out processedSize);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISequentialInStream__Read")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ISequentialInStream__Read_win(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISequentialInStream__Read")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ISequentialInStream__Read_linux(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISequentialInStream__Read")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ISequentialInStream__Read_osx(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        #endregion //ISequentialInStream_Read

        #endregion // ISequentialInStream

        #region ISequentialOutStream

        #region ISequentialOutStream_Write

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ISequentialOutStream__Write(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize)
        {
            if (OperatingSystem.IsWindows())
                return ISequentialOutStream__Write_win(ifp, data, size, out processedSize);
            else if (OperatingSystem.IsLinux())
                return ISequentialOutStream__Write_linux(ifp, data, size, out processedSize);
            else if (OperatingSystem.IsMacOS())
                return ISequentialOutStream__Write_osx(ifp, data, size, out processedSize);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISequentialOutStream__Write")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ISequentialOutStream__Write_win(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISequentialOutStream__Write")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ISequentialOutStream__Write_linux(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISequentialOutStream__Write")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ISequentialOutStream__Write_osx(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        #endregion //ISequentialOutStream_Write

        #endregion // ISequentialOutStream

        #region IInStream

#if false // IInStream interface is not supported by the wrapper.
        #region IInStream_Seek

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT IInStream__Seek(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition)
        {
            if (OperatingSystem.IsWindows())
                return IInStream__Seek_win(ifp, offset, seekOrigin, out newPosition);
            else if (OperatingSystem.IsLinux())
                return IInStream__Seek_linux(ifp, offset, seekOrigin, out newPosition);
            else if (OperatingSystem.IsMacOS())
                return IInStream__Seek_osx(ifp, offset, seekOrigin, out newPosition);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IInStream__Seek")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT IInStream__Seek_win(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IInStream__Seek")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IInStream__Seek_linux(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IInStream__Seek")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IInStream__Seek_osx(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition);

        #endregion //IInStream_Seek
#endif // IInStream interface is not supported by the wrapper.

        #endregion // IInStream

        #region IOutStream

#if false // IOutStream interface is not supported by the wrapper.
        #region IOutStream_Seek

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT IOutStream__Seek(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition)
        {
            if (OperatingSystem.IsWindows())
                return IOutStream__Seek_win(ifp, offset, seekOrigin, out newPosition);
            else if (OperatingSystem.IsLinux())
                return IOutStream__Seek_linux(ifp, offset, seekOrigin, out newPosition);
            else if (OperatingSystem.IsMacOS())
                return IOutStream__Seek_osx(ifp, offset, seekOrigin, out newPosition);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStream__Seek")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT IOutStream__Seek_win(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStream__Seek")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IOutStream__Seek_linux(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStream__Seek")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IOutStream__Seek_osx(IntPtr ifp, Int64 offset, UInt32 seekOrigin, out UInt64 newPosition);

        #endregion //IOutStream_Seek

        #region IOutStream_SetSize

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT IOutStream__SetSize(IntPtr ifp, UInt64 newSize)
        {
            if (OperatingSystem.IsWindows())
                return IOutStream__SetSize_win(ifp, newSize);
            else if (OperatingSystem.IsLinux())
                return IOutStream__SetSize_linux(ifp, newSize);
            else if (OperatingSystem.IsMacOS())
                return IOutStream__SetSize_osx(ifp, newSize);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStream__SetSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT IOutStream__SetSize_win(IntPtr ifp, UInt64 newSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStream__SetSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IOutStream__SetSize_linux(IntPtr ifp, UInt64 newSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStream__SetSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IOutStream__SetSize_osx(IntPtr ifp, UInt64 newSize);

        #endregion //IOutStream_SetSize
#endif // IOutStream interface is not supported by the wrapper.

        #endregion // IOutStream

        #region IStreamGetSize

#if false // IStreamGetSize interface is not supported by the wrapper.
        #region IStreamGetSize_GetSize

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT IStreamGetSize__GetSize(IntPtr ifp, out UInt64 size)
        {
            if (OperatingSystem.IsWindows())
                return IStreamGetSize__GetSize_win(ifp, out size);
            else if (OperatingSystem.IsLinux())
                return IStreamGetSize__GetSize_linux(ifp, out size);
            else if (OperatingSystem.IsMacOS())
                return IStreamGetSize__GetSize_osx(ifp, out size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetSize__GetSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT IStreamGetSize__GetSize_win(IntPtr ifp, out UInt64 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetSize__GetSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IStreamGetSize__GetSize_linux(IntPtr ifp, out UInt64 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetSize__GetSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IStreamGetSize__GetSize_osx(IntPtr ifp, out UInt64 size);

        #endregion //IStreamGetSize_GetSize
#endif // IStreamGetSize interface is not supported by the wrapper.

        #endregion // IStreamGetSize

        #region IOutStreamFinish

#if false // IOutStreamFinish interface is not supported by the wrapper.
        #region IOutStreamFinish_OutStreamFinish

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT IOutStreamFinish__OutStreamFinish(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return IOutStreamFinish__OutStreamFinish_win(ifp);
            else if (OperatingSystem.IsLinux())
                return IOutStreamFinish__OutStreamFinish_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return IOutStreamFinish__OutStreamFinish_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStreamFinish__OutStreamFinish")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT IOutStreamFinish__OutStreamFinish_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStreamFinish__OutStreamFinish")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IOutStreamFinish__OutStreamFinish_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IOutStreamFinish__OutStreamFinish")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT IOutStreamFinish__OutStreamFinish_osx(IntPtr ifp);

        #endregion //IOutStreamFinish_OutStreamFinish
#endif // IOutStreamFinish interface is not supported by the wrapper.

        #endregion // IOutStreamFinish

        #region IStreamGetProps

#if false // IStreamGetProps interface is not supported by the wrapper.
        #region IStreamGetProps_GetProps

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT IStreamGetProps__GetProps(IntPtr ifp, UInt64* size, void* cTime, void* aTime, void* mTime, UInt32* attrib)
        {
            if (OperatingSystem.IsWindows())
                return IStreamGetProps__GetProps_win(ifp, size, cTime, aTime, mTime, attrib);
            else if (OperatingSystem.IsLinux())
                return IStreamGetProps__GetProps_linux(ifp, size, cTime, aTime, mTime, attrib);
            else if (OperatingSystem.IsMacOS())
                return IStreamGetProps__GetProps_osx(ifp, size, cTime, aTime, mTime, attrib);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetProps__GetProps")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT IStreamGetProps__GetProps_win(IntPtr ifp, UInt64* size, void* cTime, void* aTime, void* mTime, UInt32* attrib);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetProps__GetProps")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IStreamGetProps__GetProps_linux(IntPtr ifp, UInt64* size, void* cTime, void* aTime, void* mTime, UInt32* attrib);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetProps__GetProps")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IStreamGetProps__GetProps_osx(IntPtr ifp, UInt64* size, void* cTime, void* aTime, void* mTime, UInt32* attrib);

        #endregion //IStreamGetProps_GetProps
#endif // IStreamGetProps interface is not supported by the wrapper.

        #endregion // IStreamGetProps

        #region IStreamGetProps2

#if false // IStreamGetProps2 interface is not supported by the wrapper.
        #region IStreamGetProps2_GetProps2

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT IStreamGetProps2__GetProps2(IntPtr ifp, void* props)
        {
            if (OperatingSystem.IsWindows())
                return IStreamGetProps2__GetProps2_win(ifp, props);
            else if (OperatingSystem.IsLinux())
                return IStreamGetProps2__GetProps2_linux(ifp, props);
            else if (OperatingSystem.IsMacOS())
                return IStreamGetProps2__GetProps2_osx(ifp, props);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetProps2__GetProps2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT IStreamGetProps2__GetProps2_win(IntPtr ifp, void* props);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetProps2__GetProps2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IStreamGetProps2__GetProps2_linux(IntPtr ifp, void* props);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IStreamGetProps2__GetProps2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IStreamGetProps2__GetProps2_osx(IntPtr ifp, void* props);

        #endregion //IStreamGetProps2_GetProps2
#endif // IStreamGetProps2 interface is not supported by the wrapper.

        #endregion // IStreamGetProps2

        #region ICompressProgressInfo

        #region ICompressProgressInfo_SetRatioInfo

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressProgressInfo__SetRatioInfo(IntPtr ifp, UInt64* inSize, UInt64* outSize)
        {
            if (OperatingSystem.IsWindows())
                return ICompressProgressInfo__SetRatioInfo_win(ifp, inSize, outSize);
            else if (OperatingSystem.IsLinux())
                return ICompressProgressInfo__SetRatioInfo_linux(ifp, inSize, outSize);
            else if (OperatingSystem.IsMacOS())
                return ICompressProgressInfo__SetRatioInfo_osx(ifp, inSize, outSize);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressProgressInfo__SetRatioInfo")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressProgressInfo__SetRatioInfo_win(IntPtr ifp, UInt64* inSize, UInt64* outSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressProgressInfo__SetRatioInfo")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressProgressInfo__SetRatioInfo_linux(IntPtr ifp, UInt64* inSize, UInt64* outSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressProgressInfo__SetRatioInfo")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressProgressInfo__SetRatioInfo_osx(IntPtr ifp, UInt64* inSize, UInt64* outSize);

        #endregion //ICompressProgressInfo_SetRatioInfo

        #endregion // ICompressProgressInfo

        #region ICompressCoder

        #region ICompressCoder_Code

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressCoder__Code(IntPtr ifp, NativeInStreamReader inStreamReader, NativeOutStreamWriter outStreamWriter, UInt64* inSize, UInt64* outSize, NativeProgressReporter? progressReporter)
        {
            if (OperatingSystem.IsWindows())
                return ICompressCoder__Code_win(ifp, inStreamReader, outStreamWriter, inSize, outSize, progressReporter);
            else if (OperatingSystem.IsLinux())
                return ICompressCoder__Code_linux(ifp, inStreamReader, outStreamWriter, inSize, outSize, progressReporter);
            else if (OperatingSystem.IsMacOS())
                return ICompressCoder__Code_osx(ifp, inStreamReader, outStreamWriter, inSize, outSize, progressReporter);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCoder__Code")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressCoder__Code_win(IntPtr ifp, NativeInStreamReader inStreamReader, NativeOutStreamWriter outStreamWriter, UInt64* inSize, UInt64* outSize, NativeProgressReporter? progressReporter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCoder__Code")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressCoder__Code_linux(IntPtr ifp, NativeInStreamReader inStreamReader, NativeOutStreamWriter outStreamWriter, UInt64* inSize, UInt64* outSize, NativeProgressReporter? progressReporter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCoder__Code")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressCoder__Code_osx(IntPtr ifp, NativeInStreamReader inStreamReader, NativeOutStreamWriter outStreamWriter, UInt64* inSize, UInt64* outSize, NativeProgressReporter? progressReporter);

        #endregion //ICompressCoder_Code

        #endregion // ICompressCoder

        #region ICompressCoder2

        #region ICompressCoder2_Code

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressCoder2__Code(IntPtr ifp, IntPtr inStreamReaders, UInt64** inSizes, UInt32 numInStreams, IntPtr outStreamWriters, UInt64** outSizes, UInt32 numOutStreams, NativeProgressReporter? progressReporter)
        {
            if (OperatingSystem.IsWindows())
                return ICompressCoder2__Code_win(ifp, inStreamReaders, inSizes, numInStreams, outStreamWriters, outSizes, numOutStreams, progressReporter);
            else if (OperatingSystem.IsLinux())
                return ICompressCoder2__Code_linux(ifp, inStreamReaders, inSizes, numInStreams, outStreamWriters, outSizes, numOutStreams, progressReporter);
            else if (OperatingSystem.IsMacOS())
                return ICompressCoder2__Code_osx(ifp, inStreamReaders, inSizes, numInStreams, outStreamWriters, outSizes, numOutStreams, progressReporter);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCoder2__Code")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressCoder2__Code_win(IntPtr ifp, IntPtr inStreamReaders, UInt64** inSizes, UInt32 numInStreams, IntPtr outStreamWriters, UInt64** outSizes, UInt32 numOutStreams, NativeProgressReporter? progressReporter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCoder2__Code")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressCoder2__Code_linux(IntPtr ifp, IntPtr inStreamReaders, UInt64** inSizes, UInt32 numInStreams, IntPtr outStreamWriters, UInt64** outSizes, UInt32 numOutStreams, NativeProgressReporter? progressReporter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCoder2__Code")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressCoder2__Code_osx(IntPtr ifp, IntPtr inStreamReaders, UInt64** inSizes, UInt32 numInStreams, IntPtr outStreamWriters, UInt64** outSizes, UInt32 numOutStreams, NativeProgressReporter? progressReporter);

        #endregion //ICompressCoder2_Code

        #endregion // ICompressCoder2

        #region ICompressSetCoderPropertiesOpt

        #region ICompressSetCoderPropertiesOpt_SetCoderPropertiesOpt

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt_win(ifp, propIDs, props, numProps);
            else if (OperatingSystem.IsLinux())
                return ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt_linux(ifp, propIDs, props, numProps);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt_osx(ifp, propIDs, props, numProps);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt_win(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt_linux(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetCoderPropertiesOpt__SetCoderPropertiesOpt_osx(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps);

        #endregion //ICompressSetCoderPropertiesOpt_SetCoderPropertiesOpt

        #endregion // ICompressSetCoderPropertiesOpt

        #region ICompressSetCoderProperties

        #region ICompressSetCoderProperties_SetCoderProperties

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressSetCoderProperties__SetCoderProperties(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetCoderProperties__SetCoderProperties_win(ifp, propIDs, props, numProps);
            else if (OperatingSystem.IsLinux())
                return ICompressSetCoderProperties__SetCoderProperties_linux(ifp, propIDs, props, numProps);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetCoderProperties__SetCoderProperties_osx(ifp, propIDs, props, numProps);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderProperties__SetCoderProperties")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressSetCoderProperties__SetCoderProperties_win(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderProperties__SetCoderProperties")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetCoderProperties__SetCoderProperties_linux(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderProperties__SetCoderProperties")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetCoderProperties__SetCoderProperties_osx(IntPtr ifp, CoderPropertyId* propIDs, PROPVARIANT* props, UInt32 numProps);

        #endregion //ICompressSetCoderProperties_SetCoderProperties

        #endregion // ICompressSetCoderProperties

        #region ICompressSetDecoderProperties2

        #region ICompressSetDecoderProperties2_SetDecoderProperties2

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressSetDecoderProperties2__SetDecoderProperties2(IntPtr ifp, Byte* data, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetDecoderProperties2__SetDecoderProperties2_win(ifp, data, size);
            else if (OperatingSystem.IsLinux())
                return ICompressSetDecoderProperties2__SetDecoderProperties2_linux(ifp, data, size);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetDecoderProperties2__SetDecoderProperties2_osx(ifp, data, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetDecoderProperties2__SetDecoderProperties2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressSetDecoderProperties2__SetDecoderProperties2_win(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetDecoderProperties2__SetDecoderProperties2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetDecoderProperties2__SetDecoderProperties2_linux(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetDecoderProperties2__SetDecoderProperties2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetDecoderProperties2__SetDecoderProperties2_osx(IntPtr ifp, Byte* data, UInt32 size);

        #endregion //ICompressSetDecoderProperties2_SetDecoderProperties2

        #endregion // ICompressSetDecoderProperties2

        #region ICompressWriteCoderProperties

        #region ICompressWriteCoderProperties_WriteCoderProperties

        /// <summary>
        /// Writes the coder's content property to the specified output stream.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressWriteCoderProperties interface object.</param>
        /// <param name="outStreamWriter">Set a delegate for the function that writes the data to the output stream.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressWriteCoderProperties__WriteCoderProperties(IntPtr ifp, NativeOutStreamWriter outStreamWriter)
        {
            if (OperatingSystem.IsWindows())
                return ICompressWriteCoderProperties__WriteCoderProperties_win(ifp, outStreamWriter);
            else if (OperatingSystem.IsLinux())
                return ICompressWriteCoderProperties__WriteCoderProperties_linux(ifp, outStreamWriter);
            else if (OperatingSystem.IsMacOS())
                return ICompressWriteCoderProperties__WriteCoderProperties_osx(ifp, outStreamWriter);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressWriteCoderProperties__WriteCoderProperties")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressWriteCoderProperties__WriteCoderProperties_win(IntPtr ifp, NativeOutStreamWriter outStreamWriter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressWriteCoderProperties__WriteCoderProperties")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressWriteCoderProperties__WriteCoderProperties_linux(IntPtr ifp, NativeOutStreamWriter outStreamWriter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressWriteCoderProperties__WriteCoderProperties")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressWriteCoderProperties__WriteCoderProperties_osx(IntPtr ifp, NativeOutStreamWriter outStreamWriter);

        #endregion //ICompressWriteCoderProperties_WriteCoderProperties

        #endregion // ICompressWriteCoderProperties

        #region ICompressGetInStreamProcessedSize

        #region ICompressGetInStreamProcessedSize_GetInStreamProcessedSize

        /// <summary>
        /// Gets the length of the data that the coder reads from the input stream and processes.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressGetInStreamProcessedSize interface object.</param>
        /// <param name="value">If the call to this function is successful, the total number of bytes of data read and processed from the input stream will be output.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressGetInStreamProcessedSize__GetInStreamProcessedSize(IntPtr ifp, out UInt64 value)
        {
            if (OperatingSystem.IsWindows())
                return ICompressGetInStreamProcessedSize__GetInStreamProcessedSize_win(ifp, out value);
            else if (OperatingSystem.IsLinux())
                return ICompressGetInStreamProcessedSize__GetInStreamProcessedSize_linux(ifp, out value);
            else if (OperatingSystem.IsMacOS())
                return ICompressGetInStreamProcessedSize__GetInStreamProcessedSize_osx(ifp, out value);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetInStreamProcessedSize__GetInStreamProcessedSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressGetInStreamProcessedSize__GetInStreamProcessedSize_win(IntPtr ifp, out UInt64 value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetInStreamProcessedSize__GetInStreamProcessedSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressGetInStreamProcessedSize__GetInStreamProcessedSize_linux(IntPtr ifp, out UInt64 value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetInStreamProcessedSize__GetInStreamProcessedSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressGetInStreamProcessedSize__GetInStreamProcessedSize_osx(IntPtr ifp, out UInt64 value);

        #endregion //ICompressGetInStreamProcessedSize_GetInStreamProcessedSize

        #endregion // ICompressGetInStreamProcessedSize

        #region ICompressSetCoderMt

        #region ICompressSetCoderMt_SetNumberOfThreads

        /// <summary>
        /// Sets the number of threads used by the coder.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressSetCoderMt interface object.</param>
        /// <param name="numThreads">Set the number of threads that the coder can use.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        /// <remarks>The behavior of this method depends on the implementation in the codec. Note that the number of threads actually used by the coder does not always match the value specified by <paramref name="numThreads"/>.</remarks>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetCoderMt__SetNumberOfThreads(IntPtr ifp, UInt32 numThreads)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetCoderMt__SetNumberOfThreads_win(ifp, numThreads);
            else if (OperatingSystem.IsLinux())
                return ICompressSetCoderMt__SetNumberOfThreads_linux(ifp, numThreads);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetCoderMt__SetNumberOfThreads_osx(ifp, numThreads);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderMt__SetNumberOfThreads")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetCoderMt__SetNumberOfThreads_win(IntPtr ifp, UInt32 numThreads);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderMt__SetNumberOfThreads")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetCoderMt__SetNumberOfThreads_linux(IntPtr ifp, UInt32 numThreads);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetCoderMt__SetNumberOfThreads")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetCoderMt__SetNumberOfThreads_osx(IntPtr ifp, UInt32 numThreads);

        #endregion //ICompressSetCoderMt_SetNumberOfThreads

        #endregion // ICompressSetCoderMt

        #region ICompressSetFinishMode

        #region ICompressSetFinishMode_SetFinishMode

        /// <summary>
        /// Sets whether the coding is complete in one stream.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressSetFinishMode interface object.</param>
        /// <param name="finishMode">Set true if the coding is complete in one stream, false if the coding spans multiple streams.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        /// <remarks>Note that for most codecs, the default behavior if you do not call this method is to code across multiple streams.</remarks>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetFinishMode__SetFinishMode(IntPtr ifp, UInt32 finishMode)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetFinishMode__SetFinishMode_win(ifp, finishMode);
            else if (OperatingSystem.IsLinux())
                return ICompressSetFinishMode__SetFinishMode_linux(ifp, finishMode);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetFinishMode__SetFinishMode_osx(ifp, finishMode);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetFinishMode__SetFinishMode")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetFinishMode__SetFinishMode_win(IntPtr ifp, UInt32 finishMode);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetFinishMode__SetFinishMode")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetFinishMode__SetFinishMode_linux(IntPtr ifp, UInt32 finishMode);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetFinishMode__SetFinishMode")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetFinishMode__SetFinishMode_osx(IntPtr ifp, UInt32 finishMode);

        #endregion //ICompressSetFinishMode_SetFinishMode

        #endregion // ICompressSetFinishMode

        #region ICompressGetInStreamProcessedSize2

#if false // ICompressGetInStreamProcessedSize2 interface is not supported by the wrapper.
        #region ICompressGetInStreamProcessedSize2_GetInStreamProcessedSize2

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2(IntPtr ifp, UInt32 streamIndex, out UInt64 value)
        {
            if (OperatingSystem.IsWindows())
                return ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2_win(ifp, streamIndex, out value);
            else if (OperatingSystem.IsLinux())
                return ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2_linux(ifp, streamIndex, out value);
            else if (OperatingSystem.IsMacOS())
                return ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2_osx(ifp, streamIndex, out value);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2_win(IntPtr ifp, UInt32 streamIndex, out UInt64 value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2_linux(IntPtr ifp, UInt32 streamIndex, out UInt64 value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressGetInStreamProcessedSize2__GetInStreamProcessedSize2_osx(IntPtr ifp, UInt32 streamIndex, out UInt64 value);

        #endregion //ICompressGetInStreamProcessedSize2_GetInStreamProcessedSize2
#endif // ICompressGetInStreamProcessedSize2 interface is not supported by the wrapper.

        #endregion // ICompressGetInStreamProcessedSize2

        #region ICompressSetMemLimit

        #region ICompressSetMemLimit_SetMemLimit

        /// <summary>
        /// Sets the amount of memory that the coder can use.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressSetMemLimit interface object.</param>
        /// <param name="memUsage">The size of the memory that can be used by the coder in bytes.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetMemLimit__SetMemLimit(IntPtr ifp, UInt64 memUsage)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetMemLimit__SetMemLimit_win(ifp, memUsage);
            else if (OperatingSystem.IsLinux())
                return ICompressSetMemLimit__SetMemLimit_linux(ifp, memUsage);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetMemLimit__SetMemLimit_osx(ifp, memUsage);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetMemLimit__SetMemLimit")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetMemLimit__SetMemLimit_win(IntPtr ifp, UInt64 memUsage);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetMemLimit__SetMemLimit")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetMemLimit__SetMemLimit_linux(IntPtr ifp, UInt64 memUsage);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetMemLimit__SetMemLimit")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetMemLimit__SetMemLimit_osx(IntPtr ifp, UInt64 memUsage);

        #endregion //ICompressSetMemLimit_SetMemLimit

        #endregion // ICompressSetMemLimit

        #region ICompressReadUnusedFromInBuf

        #region ICompressReadUnusedFromInBuf_ReadUnusedFromInBuf

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize)
        {
            if (OperatingSystem.IsWindows())
                return ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf_win(ifp, data, size, out processedSize);
            else if (OperatingSystem.IsLinux())
                return ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf_linux(ifp, data, size, out processedSize);
            else if (OperatingSystem.IsMacOS())
                return ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf_osx(ifp, data, size, out processedSize);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf_win(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf_linux(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressReadUnusedFromInBuf__ReadUnusedFromInBuf_osx(IntPtr ifp, void* data, UInt32 size, out UInt32 processedSize);

        #endregion //ICompressReadUnusedFromInBuf_ReadUnusedFromInBuf

        #endregion // ICompressReadUnusedFromInBuf

        #region ICompressGetSubStreamSize

#if false // ICompressGetSubStreamSize interface is not supported by the wrapper.
        #region ICompressGetSubStreamSize_GetSubStreamSize

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressGetSubStreamSize__GetSubStreamSize(IntPtr ifp, UInt64 subStream, out UInt64 value)
        {
            if (OperatingSystem.IsWindows())
                return ICompressGetSubStreamSize__GetSubStreamSize_win(ifp, subStream, out value);
            else if (OperatingSystem.IsLinux())
                return ICompressGetSubStreamSize__GetSubStreamSize_linux(ifp, subStream, out value);
            else if (OperatingSystem.IsMacOS())
                return ICompressGetSubStreamSize__GetSubStreamSize_osx(ifp, subStream, out value);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetSubStreamSize__GetSubStreamSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressGetSubStreamSize__GetSubStreamSize_win(IntPtr ifp, UInt64 subStream, out UInt64 value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetSubStreamSize__GetSubStreamSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressGetSubStreamSize__GetSubStreamSize_linux(IntPtr ifp, UInt64 subStream, out UInt64 value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressGetSubStreamSize__GetSubStreamSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressGetSubStreamSize__GetSubStreamSize_osx(IntPtr ifp, UInt64 subStream, out UInt64 value);

        #endregion //ICompressGetSubStreamSize_GetSubStreamSize
#endif // ICompressGetSubStreamSize interface is not supported by the wrapper.

        #endregion // ICompressGetSubStreamSize

        #region ICompressSetInStream

        #region ICompressSetInStream_SetInStream

        /// <summary>
        /// Set the input stream to the coder.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressSetInStream interface object.</param>
        /// <param name="inStreamReader">Set the delegate for the function that reads the data from the input stream.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetInStream__SetInStream(IntPtr ifp, NativeInStreamReader inStreamReader)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetInStream__SetInStream_win(ifp, inStreamReader);
            else if (OperatingSystem.IsLinux())
                return ICompressSetInStream__SetInStream_linux(ifp, inStreamReader);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetInStream__SetInStream_osx(ifp, inStreamReader);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream__SetInStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetInStream__SetInStream_win(IntPtr ifp, NativeInStreamReader inStreamReader);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream__SetInStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream__SetInStream_linux(IntPtr ifp, NativeInStreamReader inStreamReader);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream__SetInStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream__SetInStream_osx(IntPtr ifp, NativeInStreamReader inStreamReader);

        #endregion //ICompressSetInStream_SetInStream

        #region ICompressSetInStream_ReleaseInStream

        /// <summary>
        /// Releases the input stream set in the coder.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressSetInStream interface object.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetInStream__ReleaseInStream(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetInStream__ReleaseInStream_win(ifp);
            else if (OperatingSystem.IsLinux())
                return ICompressSetInStream__ReleaseInStream_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetInStream__ReleaseInStream_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream__ReleaseInStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetInStream__ReleaseInStream_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream__ReleaseInStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream__ReleaseInStream_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream__ReleaseInStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream__ReleaseInStream_osx(IntPtr ifp);

        #endregion //ICompressSetInStream_ReleaseInStream

        #endregion // ICompressSetInStream

        #region ICompressSetOutStream

#if false // ICompressSetOutStream interface is not supported by the wrapper.
        #region ICompressSetOutStream_SetOutStream

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetOutStream__SetOutStream(IntPtr ifp, NativeOutStreamWriter outStreamWriter)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetOutStream__SetOutStream_win(ifp, outStreamWriter);
            else if (OperatingSystem.IsLinux())
                return ICompressSetOutStream__SetOutStream_linux(ifp, outStreamWriter);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetOutStream__SetOutStream_osx(ifp, outStreamWriter);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStream__SetOutStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetOutStream__SetOutStream_win(IntPtr ifp, NativeOutStreamWriter outStreamWriter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStream__SetOutStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetOutStream__SetOutStream_linux(IntPtr ifp, NativeOutStreamWriter outStreamWriter);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStream__SetOutStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetOutStream__SetOutStream_osx(IntPtr ifp, NativeOutStreamWriter outStreamWriter);

        #endregion //ICompressSetOutStream_SetOutStream

        #region ICompressSetOutStream_ReleaseOutStream

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetOutStream__ReleaseOutStream(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetOutStream__ReleaseOutStream_win(ifp);
            else if (OperatingSystem.IsLinux())
                return ICompressSetOutStream__ReleaseOutStream_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetOutStream__ReleaseOutStream_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStream__ReleaseOutStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetOutStream__ReleaseOutStream_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStream__ReleaseOutStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetOutStream__ReleaseOutStream_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStream__ReleaseOutStream")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetOutStream__ReleaseOutStream_osx(IntPtr ifp);

        #endregion //ICompressSetOutStream_ReleaseOutStream
#endif // ICompressSetOutStream interface is not supported by the wrapper.

        #endregion // ICompressSetOutStream

        #region ICompressSetOutStreamSize

        #region ICompressSetOutStreamSize_SetOutStreamSize

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressSetOutStreamSize__SetOutStreamSize(IntPtr ifp, UInt64* outSize)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetOutStreamSize__SetOutStreamSize_win(ifp, outSize);
            else if (OperatingSystem.IsLinux())
                return ICompressSetOutStreamSize__SetOutStreamSize_linux(ifp, outSize);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetOutStreamSize__SetOutStreamSize_osx(ifp, outSize);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStreamSize__SetOutStreamSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressSetOutStreamSize__SetOutStreamSize_win(IntPtr ifp, UInt64* outSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStreamSize__SetOutStreamSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetOutStreamSize__SetOutStreamSize_linux(IntPtr ifp, UInt64* outSize);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetOutStreamSize__SetOutStreamSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressSetOutStreamSize__SetOutStreamSize_osx(IntPtr ifp, UInt64* outSize);

        #endregion //ICompressSetOutStreamSize_SetOutStreamSize

        #endregion // ICompressSetOutStreamSize

        #region ICompressSetBufSize

        #region ICompressSetBufSize_SetInBufSize

        /// <summary>
        /// Sets the size of the buffer used by the coder for the input stream.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressSetBufSize interface object.</param>
        /// <param name="streamIndex">Set the index number of the stream for which you want to set the size.</param>
        /// <param name="size">Set the amount of memory used for the stream in bytes.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetBufSize__SetInBufSize(IntPtr ifp, UInt32 streamIndex, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetBufSize__SetInBufSize_win(ifp, streamIndex, size);
            else if (OperatingSystem.IsLinux())
                return ICompressSetBufSize__SetInBufSize_linux(ifp, streamIndex, size);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetBufSize__SetInBufSize_osx(ifp, streamIndex, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetBufSize__SetInBufSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetBufSize__SetInBufSize_win(IntPtr ifp, UInt32 streamIndex, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetBufSize__SetInBufSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetBufSize__SetInBufSize_linux(IntPtr ifp, UInt32 streamIndex, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetBufSize__SetInBufSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetBufSize__SetInBufSize_osx(IntPtr ifp, UInt32 streamIndex, UInt32 size);

        #endregion //ICompressSetBufSize_SetInBufSize

        #region ICompressSetBufSize_SetOutBufSize

        /// <summary>
        /// Sets the size of the buffer used by the coder for the output stream.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressSetBufSize interface object.</param>
        /// <param name="streamIndex">Set the index number of the stream for which you want to set the size.</param>
        /// <param name="size">Set the amount of memory used for the stream in bytes.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetBufSize__SetOutBufSize(IntPtr ifp, UInt32 streamIndex, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetBufSize__SetOutBufSize_win(ifp, streamIndex, size);
            else if (OperatingSystem.IsLinux())
                return ICompressSetBufSize__SetOutBufSize_linux(ifp, streamIndex, size);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetBufSize__SetOutBufSize_osx(ifp, streamIndex, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetBufSize__SetOutBufSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetBufSize__SetOutBufSize_win(IntPtr ifp, UInt32 streamIndex, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetBufSize__SetOutBufSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetBufSize__SetOutBufSize_linux(IntPtr ifp, UInt32 streamIndex, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetBufSize__SetOutBufSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetBufSize__SetOutBufSize_osx(IntPtr ifp, UInt32 streamIndex, UInt32 size);

        #endregion //ICompressSetBufSize_SetOutBufSize

        #endregion // ICompressSetBufSize

        #region ICompressInitEncoder

#if false // ICompressInitEncoder interface is not supported by the wrapper.
        #region ICompressInitEncoder_InitEncoder

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressInitEncoder__InitEncoder(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return ICompressInitEncoder__InitEncoder_win(ifp);
            else if (OperatingSystem.IsLinux())
                return ICompressInitEncoder__InitEncoder_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return ICompressInitEncoder__InitEncoder_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressInitEncoder__InitEncoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressInitEncoder__InitEncoder_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressInitEncoder__InitEncoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressInitEncoder__InitEncoder_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressInitEncoder__InitEncoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressInitEncoder__InitEncoder_osx(IntPtr ifp);

        #endregion //ICompressInitEncoder_InitEncoder
#endif // ICompressInitEncoder interface is not supported by the wrapper.

        #endregion // ICompressInitEncoder

        #region ICompressSetInStream2

#if false // ICompressSetInStream2 interface is not supported by the wrapper.
        #region ICompressSetInStream2_SetInStream2

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetInStream2__SetInStream2(IntPtr ifp, UInt32 streamIndex, NativeInStreamReader inStreamReader)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetInStream2__SetInStream2_win(ifp, streamIndex, inStreamReader);
            else if (OperatingSystem.IsLinux())
                return ICompressSetInStream2__SetInStream2_linux(ifp, streamIndex, inStreamReader);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetInStream2__SetInStream2_osx(ifp, streamIndex, inStreamReader);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream2__SetInStream2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetInStream2__SetInStream2_win(IntPtr ifp, UInt32 streamIndex, NativeInStreamReader inStreamReader);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream2__SetInStream2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream2__SetInStream2_linux(IntPtr ifp, UInt32 streamIndex, NativeInStreamReader inStreamReader);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream2__SetInStream2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream2__SetInStream2_osx(IntPtr ifp, UInt32 streamIndex, NativeInStreamReader inStreamReader);

        #endregion //ICompressSetInStream2_SetInStream2

        #region ICompressSetInStream2_ReleaseInStream2

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressSetInStream2__ReleaseInStream2(IntPtr ifp, UInt32 streamIndex)
        {
            if (OperatingSystem.IsWindows())
                return ICompressSetInStream2__ReleaseInStream2_win(ifp, streamIndex);
            else if (OperatingSystem.IsLinux())
                return ICompressSetInStream2__ReleaseInStream2_linux(ifp, streamIndex);
            else if (OperatingSystem.IsMacOS())
                return ICompressSetInStream2__ReleaseInStream2_osx(ifp, streamIndex);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream2__ReleaseInStream2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressSetInStream2__ReleaseInStream2_win(IntPtr ifp, UInt32 streamIndex);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream2__ReleaseInStream2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream2__ReleaseInStream2_linux(IntPtr ifp, UInt32 streamIndex);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressSetInStream2__ReleaseInStream2")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressSetInStream2__ReleaseInStream2_osx(IntPtr ifp, UInt32 streamIndex);

        #endregion //ICompressSetInStream2_ReleaseInStream2
#endif // ICompressSetInStream2 interface is not supported by the wrapper.

        #endregion // ICompressSetInStream2

        #region ICompressFilter

        #region ICompressFilter_Init

        /// <summary>
        /// Initialize the filter.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressFilter interface object.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressFilter__Init(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return ICompressFilter__Init_win(ifp);
            else if (OperatingSystem.IsLinux())
                return ICompressFilter__Init_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return ICompressFilter__Init_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressFilter__Init")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressFilter__Init_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressFilter__Init")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressFilter__Init_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressFilter__Init")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressFilter__Init_osx(IntPtr ifp);

        #endregion //ICompressFilter_Init

        #region ICompressFilter_Filter

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe UInt32 ICompressFilter__Filter(IntPtr ifp, Byte* data, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return ICompressFilter__Filter_win(ifp, data, size);
            else if (OperatingSystem.IsLinux())
                return ICompressFilter__Filter_linux(ifp, data, size);
            else if (OperatingSystem.IsMacOS())
                return ICompressFilter__Filter_osx(ifp, data, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressFilter__Filter")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial UInt32 ICompressFilter__Filter_win(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressFilter__Filter")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial UInt32 ICompressFilter__Filter_linux(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressFilter__Filter")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial UInt32 ICompressFilter__Filter_osx(IntPtr ifp, Byte* data, UInt32 size);

        #endregion //ICompressFilter_Filter

        #endregion // ICompressFilter

        #region ICompressCodecsInfo

        #region ICompressCodecsInfo_GetNumMethods

        /// <summary>
        /// Gets the number of supported codecs.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressCodecsInfo interface object.</param>
        /// <param name="numMethods">If the call to this function is successful, the number of supported codecs will be output.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressCodecsInfo__GetNumMethods(IntPtr ifp, out UInt32 numMethods)
        {
            if (OperatingSystem.IsWindows())
                return ICompressCodecsInfo__GetNumMethods_win(ifp, out numMethods);
            else if (OperatingSystem.IsLinux())
                return ICompressCodecsInfo__GetNumMethods_linux(ifp, out numMethods);
            else if (OperatingSystem.IsMacOS())
                return ICompressCodecsInfo__GetNumMethods_osx(ifp, out numMethods);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__GetNumMethods")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressCodecsInfo__GetNumMethods_win(IntPtr ifp, out UInt32 numMethods);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__GetNumMethods")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressCodecsInfo__GetNumMethods_linux(IntPtr ifp, out UInt32 numMethods);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__GetNumMethods")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressCodecsInfo__GetNumMethods_osx(IntPtr ifp, out UInt32 numMethods);

        #endregion //ICompressCodecsInfo_GetNumMethods

        #region ICompressCodecsInfo_GetProperty

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICompressCodecsInfo__GetProperty(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value)
        {
            if (OperatingSystem.IsWindows())
                return ICompressCodecsInfo__GetProperty_win(ifp, index, propID, value);
            else if (OperatingSystem.IsLinux())
                return ICompressCodecsInfo__GetProperty_linux(ifp, index, propID, value);
            else if (OperatingSystem.IsMacOS())
                return ICompressCodecsInfo__GetProperty_osx(ifp, index, propID, value);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__GetProperty")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICompressCodecsInfo__GetProperty_win(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__GetProperty")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressCodecsInfo__GetProperty_linux(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__GetProperty")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICompressCodecsInfo__GetProperty_osx(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value);

        #endregion //ICompressCodecsInfo_GetProperty

        #region ICompressCodecsInfo_CreateDecoder

        /// <summary>
        /// Create an interface object for the decoder.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressCodecsInfo interface object.</param>
        /// <param name="index">Set the codec index number.</param>
        /// <param name="iid">Set the reference of the <see cref="NativeGUID"/> structure of the interface of the decoder you want to create.</param>
        /// <param name="decoder">If the call to this function is successful, a pointer to the created decoder's interface object will be output. This interface object implements the interface specified by  <paramref name="iid"/>.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        /// <remarks><para>If the call to this function is successful, the reference counter for the retrieved interface object has already been incremented.When you no longer need that interface object, you need to decrement the reference counter by calling the <see cref="IUnknown__Release(IntPtr)"/> function.</para><para>The interface that can be specified for <paramref name="iid"/> is one of the following.:<list type="bullet"><item><description><c>ICompressCoder</c></description></item><item><description><c>ICompressCoder2</c></description></item><item><description><c>ICompressFilter</c></description></item></list></para></remarks>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressCodecsInfo__CreateDecoder(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr decoder)
        {
            if (OperatingSystem.IsWindows())
                return ICompressCodecsInfo__CreateDecoder_win(ifp, index, ref iid, out decoder);
            else if (OperatingSystem.IsLinux())
                return ICompressCodecsInfo__CreateDecoder_linux(ifp, index, ref iid, out decoder);
            else if (OperatingSystem.IsMacOS())
                return ICompressCodecsInfo__CreateDecoder_osx(ifp, index, ref iid, out decoder);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__CreateDecoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressCodecsInfo__CreateDecoder_win(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr decoder);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__CreateDecoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressCodecsInfo__CreateDecoder_linux(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr decoder);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__CreateDecoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressCodecsInfo__CreateDecoder_osx(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr decoder);

        #endregion //ICompressCodecsInfo_CreateDecoder

        #region ICompressCodecsInfo_CreateEncoder

        /// <summary>
        /// Create an interface object for the decoder.
        /// </summary>
        /// <param name="ifp">Set a pointer to the ICompressCodecsInfo interface object.</param>
        /// <param name="index">Set the codec index number.</param>
        /// <param name="iid">Set the reference of the <see cref="NativeGUID"/> structure of the interface of the encoder you want to create.</param>
        /// <param name="encoder">If the call to this function is successful, a pointer to the created decoder's interface object will be output. This interface object implements the interface specified by  <paramref name="iid"/>.</param>
        /// <returns><para>If the return value is <see cref="HRESULT.S_OK"/>, it means that the call to this function was successful.</para><para>If the return value is not <see cref="HRESULT.S_OK"/>, it means that the call to this function failed.At this time, the return value means the reason for the failure.</para></returns>
        /// <remarks><para>If the call to this function is successful, the reference counter for the retrieved interface object has already been incremented.When you no longer need that interface object, you need to decrement the reference counter by calling the <see cref="IUnknown__Release(IntPtr)"/> function.</para><para>The interface that can be specified for <paramref name="iid"/> is one of the following.:<list type="bullet"><item><description><c>ICompressCoder</c></description></item><item><description><c>ICompressCoder2</c></description></item><item><description><c>ICompressFilter</c></description></item></list></para></remarks>
        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICompressCodecsInfo__CreateEncoder(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr encoder)
        {
            if (OperatingSystem.IsWindows())
                return ICompressCodecsInfo__CreateEncoder_win(ifp, index, ref iid, out encoder);
            else if (OperatingSystem.IsLinux())
                return ICompressCodecsInfo__CreateEncoder_linux(ifp, index, ref iid, out encoder);
            else if (OperatingSystem.IsMacOS())
                return ICompressCodecsInfo__CreateEncoder_osx(ifp, index, ref iid, out encoder);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__CreateEncoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICompressCodecsInfo__CreateEncoder_win(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr encoder);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__CreateEncoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressCodecsInfo__CreateEncoder_linux(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr encoder);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICompressCodecsInfo__CreateEncoder")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICompressCodecsInfo__CreateEncoder_osx(IntPtr ifp, UInt32 index, ref NativeGUID iid, out IntPtr encoder);

        #endregion //ICompressCodecsInfo_CreateEncoder

        #endregion // ICompressCodecsInfo

        #region ISetCompressCodecsInfo

#if false // ISetCompressCodecsInfo interface is not supported by the wrapper.
        #region ISetCompressCodecsInfo_SetCompressCodecsInfo

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ISetCompressCodecsInfo__SetCompressCodecsInfo(IntPtr ifp, void* compressCodecsInfo)
        {
            if (OperatingSystem.IsWindows())
                return ISetCompressCodecsInfo__SetCompressCodecsInfo_win(ifp, compressCodecsInfo);
            else if (OperatingSystem.IsLinux())
                return ISetCompressCodecsInfo__SetCompressCodecsInfo_linux(ifp, compressCodecsInfo);
            else if (OperatingSystem.IsMacOS())
                return ISetCompressCodecsInfo__SetCompressCodecsInfo_osx(ifp, compressCodecsInfo);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISetCompressCodecsInfo__SetCompressCodecsInfo")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ISetCompressCodecsInfo__SetCompressCodecsInfo_win(IntPtr ifp, void* compressCodecsInfo);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISetCompressCodecsInfo__SetCompressCodecsInfo")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ISetCompressCodecsInfo__SetCompressCodecsInfo_linux(IntPtr ifp, void* compressCodecsInfo);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ISetCompressCodecsInfo__SetCompressCodecsInfo")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ISetCompressCodecsInfo__SetCompressCodecsInfo_osx(IntPtr ifp, void* compressCodecsInfo);

        #endregion //ISetCompressCodecsInfo_SetCompressCodecsInfo
#endif // ISetCompressCodecsInfo interface is not supported by the wrapper.

        #endregion // ISetCompressCodecsInfo

        #region ICryptoProperties

#if false // ICryptoProperties interface is not supported by the wrapper.
        #region ICryptoProperties_SetKey

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICryptoProperties__SetKey(IntPtr ifp, Byte* data, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return ICryptoProperties__SetKey_win(ifp, data, size);
            else if (OperatingSystem.IsLinux())
                return ICryptoProperties__SetKey_linux(ifp, data, size);
            else if (OperatingSystem.IsMacOS())
                return ICryptoProperties__SetKey_osx(ifp, data, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoProperties__SetKey")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICryptoProperties__SetKey_win(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoProperties__SetKey")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICryptoProperties__SetKey_linux(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoProperties__SetKey")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICryptoProperties__SetKey_osx(IntPtr ifp, Byte* data, UInt32 size);

        #endregion //ICryptoProperties_SetKey

        #region ICryptoProperties_SetInitVector

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICryptoProperties__SetInitVector(IntPtr ifp, Byte* data, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return ICryptoProperties__SetInitVector_win(ifp, data, size);
            else if (OperatingSystem.IsLinux())
                return ICryptoProperties__SetInitVector_linux(ifp, data, size);
            else if (OperatingSystem.IsMacOS())
                return ICryptoProperties__SetInitVector_osx(ifp, data, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoProperties__SetInitVector")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICryptoProperties__SetInitVector_win(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoProperties__SetInitVector")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICryptoProperties__SetInitVector_linux(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoProperties__SetInitVector")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICryptoProperties__SetInitVector_osx(IntPtr ifp, Byte* data, UInt32 size);

        #endregion //ICryptoProperties_SetInitVector
#endif // ICryptoProperties interface is not supported by the wrapper.

        #endregion // ICryptoProperties

        #region ICryptoResetInitVector

#if false // ICryptoResetInitVector interface is not supported by the wrapper.
        #region ICryptoResetInitVector_ResetInitVector

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICryptoResetInitVector__ResetInitVector(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return ICryptoResetInitVector__ResetInitVector_win(ifp);
            else if (OperatingSystem.IsLinux())
                return ICryptoResetInitVector__ResetInitVector_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return ICryptoResetInitVector__ResetInitVector_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoResetInitVector__ResetInitVector")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICryptoResetInitVector__ResetInitVector_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoResetInitVector__ResetInitVector")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICryptoResetInitVector__ResetInitVector_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoResetInitVector__ResetInitVector")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICryptoResetInitVector__ResetInitVector_osx(IntPtr ifp);

        #endregion //ICryptoResetInitVector_ResetInitVector
#endif // ICryptoResetInitVector interface is not supported by the wrapper.

        #endregion // ICryptoResetInitVector

        #region ICryptoSetPassword

#if false // ICryptoSetPassword interface is not supported by the wrapper.
        #region ICryptoSetPassword_CryptoSetPassword

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT ICryptoSetPassword__CryptoSetPassword(IntPtr ifp, Byte* data, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return ICryptoSetPassword__CryptoSetPassword_win(ifp, data, size);
            else if (OperatingSystem.IsLinux())
                return ICryptoSetPassword__CryptoSetPassword_linux(ifp, data, size);
            else if (OperatingSystem.IsMacOS())
                return ICryptoSetPassword__CryptoSetPassword_osx(ifp, data, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoSetPassword__CryptoSetPassword")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT ICryptoSetPassword__CryptoSetPassword_win(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoSetPassword__CryptoSetPassword")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICryptoSetPassword__CryptoSetPassword_linux(IntPtr ifp, Byte* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoSetPassword__CryptoSetPassword")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT ICryptoSetPassword__CryptoSetPassword_osx(IntPtr ifp, Byte* data, UInt32 size);

        #endregion //ICryptoSetPassword_CryptoSetPassword
#endif // ICryptoSetPassword interface is not supported by the wrapper.

        #endregion // ICryptoSetPassword

        #region ICryptoSetCRC

#if false // ICryptoSetCRC interface is not supported by the wrapper.
        #region ICryptoSetCRC_CryptoSetCRC

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static HRESULT ICryptoSetCRC__CryptoSetCRC(IntPtr ifp, UInt32 crc)
        {
            if (OperatingSystem.IsWindows())
                return ICryptoSetCRC__CryptoSetCRC_win(ifp, crc);
            else if (OperatingSystem.IsLinux())
                return ICryptoSetCRC__CryptoSetCRC_linux(ifp, crc);
            else if (OperatingSystem.IsMacOS())
                return ICryptoSetCRC__CryptoSetCRC_osx(ifp, crc);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoSetCRC__CryptoSetCRC")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial HRESULT ICryptoSetCRC__CryptoSetCRC_win(IntPtr ifp, UInt32 crc);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoSetCRC__CryptoSetCRC")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICryptoSetCRC__CryptoSetCRC_linux(IntPtr ifp, UInt32 crc);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_ICryptoSetCRC__CryptoSetCRC")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial HRESULT ICryptoSetCRC__CryptoSetCRC_osx(IntPtr ifp, UInt32 crc);

        #endregion //ICryptoSetCRC_CryptoSetCRC
#endif // ICryptoSetCRC interface is not supported by the wrapper.

        #endregion // ICryptoSetCRC

        #region IHasher

#if false // IHasher interface is not supported by the wrapper.
        #region IHasher_Init

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static void IHasher__Init(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return IHasher__Init_win(ifp);
            else if (OperatingSystem.IsLinux())
                return IHasher__Init_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return IHasher__Init_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Init")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial void IHasher__Init_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Init")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial void IHasher__Init_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Init")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial void IHasher__Init_osx(IntPtr ifp);

        #endregion //IHasher_Init

        #region IHasher_Update

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe void IHasher__Update(IntPtr ifp, void* data, UInt32 size)
        {
            if (OperatingSystem.IsWindows())
                return IHasher__Update_win(ifp, data, size);
            else if (OperatingSystem.IsLinux())
                return IHasher__Update_linux(ifp, data, size);
            else if (OperatingSystem.IsMacOS())
                return IHasher__Update_osx(ifp, data, size);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Update")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial void IHasher__Update_win(IntPtr ifp, void* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Update")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial void IHasher__Update_linux(IntPtr ifp, void* data, UInt32 size);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Update")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial void IHasher__Update_osx(IntPtr ifp, void* data, UInt32 size);

        #endregion //IHasher_Update

        #region IHasher_Final

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe void IHasher__Final(IntPtr ifp, Byte* digest)
        {
            if (OperatingSystem.IsWindows())
                return IHasher__Final_win(ifp, digest);
            else if (OperatingSystem.IsLinux())
                return IHasher__Final_linux(ifp, digest);
            else if (OperatingSystem.IsMacOS())
                return IHasher__Final_osx(ifp, digest);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Final")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial void IHasher__Final_win(IntPtr ifp, Byte* digest);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Final")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial void IHasher__Final_linux(IntPtr ifp, Byte* digest);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__Final")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial void IHasher__Final_osx(IntPtr ifp, Byte* digest);

        #endregion //IHasher_Final

        #region IHasher_GetDigestSize

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static UInt32 IHasher__GetDigestSize(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return IHasher__GetDigestSize_win(ifp);
            else if (OperatingSystem.IsLinux())
                return IHasher__GetDigestSize_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return IHasher__GetDigestSize_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__GetDigestSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial UInt32 IHasher__GetDigestSize_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__GetDigestSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IHasher__GetDigestSize_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHasher__GetDigestSize")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IHasher__GetDigestSize_osx(IntPtr ifp);

        #endregion //IHasher_GetDigestSize
#endif // IHasher interface is not supported by the wrapper.

        #endregion // IHasher

        #region IHashers

#if false // IHashers interface is not supported by the wrapper.
        #region IHashers_GetNumHashers

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        public static UInt32 IHashers__GetNumHashers(IntPtr ifp)
        {
            if (OperatingSystem.IsWindows())
                return IHashers__GetNumHashers_win(ifp);
            else if (OperatingSystem.IsLinux())
                return IHashers__GetNumHashers_linux(ifp);
            else if (OperatingSystem.IsMacOS())
                return IHashers__GetNumHashers_osx(ifp);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__GetNumHashers")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static partial UInt32 IHashers__GetNumHashers_win(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__GetNumHashers")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IHashers__GetNumHashers_linux(IntPtr ifp);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__GetNumHashers")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static partial UInt32 IHashers__GetNumHashers_osx(IntPtr ifp);

        #endregion //IHashers_GetNumHashers

        #region IHashers_GetHasherProp

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT IHashers__GetHasherProp(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value)
        {
            if (OperatingSystem.IsWindows())
                return IHashers__GetHasherProp_win(ifp, index, propID, value);
            else if (OperatingSystem.IsLinux())
                return IHashers__GetHasherProp_linux(ifp, index, propID, value);
            else if (OperatingSystem.IsMacOS())
                return IHashers__GetHasherProp_osx(ifp, index, propID, value);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__GetHasherProp")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT IHashers__GetHasherProp_win(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__GetHasherProp")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IHashers__GetHasherProp_linux(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__GetHasherProp")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IHashers__GetHasherProp_osx(IntPtr ifp, UInt32 index, MethodPropID propID, PROPVARIANT* value);

        #endregion //IHashers_GetHasherProp

        #region IHashers_CreateHasher

        [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
        private static unsafe HRESULT IHashers__CreateHasher(IntPtr ifp, UInt32 index, void** hasher)
        {
            if (OperatingSystem.IsWindows())
                return IHashers__CreateHasher_win(ifp, index, hasher);
            else if (OperatingSystem.IsLinux())
                return IHashers__CreateHasher_linux(ifp, index, hasher);
            else if (OperatingSystem.IsMacOS())
                return IHashers__CreateHasher_osx(ifp, index, hasher);
            else
                throw new NotSupportedException("Running on this operating system is not supported.");
        }

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__CreateHasher")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvStdcall)})]
        private static unsafe partial HRESULT IHashers__CreateHasher_win(IntPtr ifp, UInt32 index, void** hasher);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__CreateHasher")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IHashers__CreateHasher_linux(IntPtr ifp, UInt32 index, void** hasher);

        [LibraryImport(_NATIVE_METHOD_DLL_NAME, EntryPoint = "EXPORTED_IHashers__CreateHasher")]
        [UnmanagedCallConv(CallConvs = new[] {typeof(CallConvCdecl)})]
        private static unsafe partial HRESULT IHashers__CreateHasher_osx(IntPtr ifp, UInt32 index, void** hasher);

        #endregion //IHashers_CreateHasher
#endif // IHashers interface is not supported by the wrapper.

        #endregion // IHashers
    }
}
